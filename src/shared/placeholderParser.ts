import type {
  Placeholder,
  PlaceholderType,
  ParsedTemplate,
  PlaceholderValues,
  ResolvedTemplate,
} from '../types/placeholder';

// Regex to match {placeholder} or {{placeholder}} patterns (captures name in group 1 or 2)
export const PLACEHOLDER_REGEX = /\{\{?([^{}]+?)\}?\}/g;

function getPlaceholderType(name: string): PlaceholderType {
  if (name === 'id' || name.startsWith('$id')) {
    return 'id';
  }
  if (name === 'timestamp' || name === '$timestamp') {
    return 'timestamp';
  }
  if (name === name.toUpperCase() && /^[A-Z_]+$/.test(name)) {
    return 'env';
  }
  return 'user';
}

export function parsePlaceholders(template: string): ParsedTemplate {
  const placeholders: Placeholder[] = [];
  let match: RegExpExecArray | null;
  let hasAutoGeneratedFields = false;

  PLACEHOLDER_REGEX.lastIndex = 0;

  while ((match = PLACEHOLDER_REGEX.exec(template)) !== null) {
    const raw = (match[1] || '').toString();
    const name = raw.trim();
    if (!name) continue;
    const type = getPlaceholderType(name);

    if (type === 'id' || type === 'timestamp') {
      hasAutoGeneratedFields = true;
    }

    placeholders.push({
      name,
      fullMatch: match[0],
      type,
      startIndex: match.index,
      endIndex: match.index + match[0].length,
    });
  }

  return {
    original: template,
    placeholders,
    hasAutoGeneratedFields,
  };
}

const ID_ALIAS_REGEX = /^\$\{id-([a-zA-Z0-9_-]+)\}$/;

function getIdAlias(value: unknown): string | undefined {
  if (typeof value !== 'string') return undefined;
  const match = value.match(ID_ALIAS_REGEX);
  return match ? match[1] : undefined;
}

export function generateUniqueId(prefix: string = 'virt'): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  return `${prefix}_${timestamp}_${random}`;
}

export function generateTimestamp(): string {
  return new Date().toISOString();
}

export function resolvePlaceholders(
  template: string,
  values: PlaceholderValues,
  options: { autoGenerate?: boolean; env?: Record<string, string | undefined> } = {}
): ResolvedTemplate {
  const { autoGenerate = true, env } = options;
  const parsed = parsePlaceholders(template);
  const generatedIds: Record<string, string> = {};
  let result = template;

  const sortedPlaceholders = [...parsed.placeholders].sort((a, b) => b.startIndex - a.startIndex);

  for (const placeholder of sortedPlaceholders) {
    let value: string;
    const provided = values[placeholder.name];
    const alias = getIdAlias(provided);

    // Alias token (${id-label}) generates and reuses an ID for any placeholder
    if (alias) {
      const aliasId = generatedIds[alias] ?? generateUniqueId();
      generatedIds[alias] = aliasId;
      generatedIds[placeholder.name] = aliasId;
      value = aliasId;
      result = result.slice(0, placeholder.startIndex) + value + result.slice(placeholder.endIndex);
      continue;
    }

    switch (placeholder.type) {
      case 'id': {
        if (typeof provided === 'string' && provided.length > 0) {
          generatedIds[placeholder.name] = provided;
          value = provided;
        } else {
          value = placeholder.fullMatch;
        }
        break;
      }
      case 'timestamp': {
        value = autoGenerate
          ? generateTimestamp()
          : values[placeholder.name] ?? placeholder.fullMatch;
        break;
      }
      case 'env': {
        const envLookup = env || (typeof process !== 'undefined' ? process.env : undefined);
        value = envLookup?.[placeholder.name] ?? values[placeholder.name] ?? '';
        break;
      }
      case 'user':
      default: {
        value = typeof provided === 'string' ? provided : placeholder.fullMatch;
        break;
      }
    }

    result = result.slice(0, placeholder.startIndex) + value + result.slice(placeholder.endIndex);
  }

  return {
    xml: result,
    generatedIds,
  };
}

export function getUserPlaceholders(template: string): Placeholder[] {
  const parsed = parsePlaceholders(template);
  return parsed.placeholders.filter((p) => p.type === 'user');
}

export function validatePlaceholders(
  template: string,
  values: PlaceholderValues
): { valid: boolean; missing: string[] } {
  const userPlaceholders = getUserPlaceholders(template);
  const missing = userPlaceholders
    .filter((p) => {
      const val = values[p.name] ?? '';
      return val.trim() === '';
    })
    .map((p) => p.name);

  return { valid: missing.length === 0, missing };
}
